import 'package:equatable/equatable.dart';
import 'package:json_annotation/json_annotation.dart';
import 'package:meta/meta.dart';

part 'choices.g.dart';

/// {@template openai_chat_completion_choice_model}
/// This class is used to represent a choice generated by an OpenAI stream completion.
/// {@endtemplate}
@immutable
@JsonSerializable(explicitToJson: true)
class OpenAIStreamCompletionModelChoice extends Equatable {
  /// {@macro openai_chat_completion_choice_model}
  const OpenAIStreamCompletionModelChoice({
    required this.text,
    required this.index,
    this.logprobs,
    this.finishReason,
  });

  /// Creates a new instance from a JSON map.
  factory OpenAIStreamCompletionModelChoice.fromJson(
          Map<String, dynamic> json) =>
      _$OpenAIStreamCompletionModelChoiceFromJson(json);

  /// Creates a new instance from a map.
  factory OpenAIStreamCompletionModelChoice.fromMap(Map<String, dynamic> map) =>
      OpenAIStreamCompletionModelChoice.fromJson(map);

  /// The reason the completion finished.
  final String? finishReason;

  /// The index of the choice.
  /// This is dynamic because the API sometimes returns a [String] and sometimes an [int].
  @JsonKey(
    name: 'index',
    fromJson: _indexFromJson,
    toJson: _indexToJson,
  )
  final dynamic index;

  /// The log probabilities of the tokens in the completion.
  final int? logprobs;

  /// The text generated by the completion.
  final String text;

  @override
  List<Object?> get props => [text, index, logprobs, finishReason];

  @override
  String toString() {
    return 'OpenAIStreamCompletionModelChoice(text: $text, index: $index, logprobs: $logprobs, finishReason: $finishReason)';
  }

  /// Whether the choice has log probabilities.
  bool get haveLogprobs => logprobs != null;

  /// Whether the choice has a finish reason.
  bool get haveFinishReason => finishReason != null;

  /// Converts the instance to a JSON map.
  Map<String, dynamic> toJson() =>
      _$OpenAIStreamCompletionModelChoiceToJson(this);

  /// Custom fromJson function to handle dynamic index.
  static dynamic _indexFromJson(index) {
    if (index is int) {
      return index;
    } else if (index is String) {
      return int.tryParse(index) ?? index;
    } else {
      return index;
    }
  }

  /// Custom toJson function for index.
  static dynamic _indexToJson(index) => index;
}
